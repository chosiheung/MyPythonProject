import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout 
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, r2_score
import os
import warnings

warnings.filterwarnings('ignore')
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' 

# --- 1. 설정 및 데이터 로드 (최적화 설정 변경) ---
file_path = r'S:\바탕화면\WOW\Simulated_Graph_Data_Precise.xlsx' 
column_name = 'Cur1_Simulated' 
look_back = 10 
FUTURE_STEPS = 500
EPOCHS = 100 # <-- Epochs 500으로 극대화
BATCH_SIZE = 5 
DROPOUT_RATE = 0.3 # <-- Dropout 0.3으로 강화

try:
    df = pd.read_excel(file_path, usecols=[column_name])
except FileNotFoundError:
    print(f"오류: 파일을 찾을 수 없습니다. 경로를 확인해 주세요: {file_path}")
    exit()
except ValueError:
    print(f"오류: 엑셀 파일에 '{column_name}' 이름의 열이 없습니다. 열 이름을 확인해 주세요.")
    exit()

data = df.values.astype('float32')
print(f"원본 데이터 크기: {data.shape}")

# --- 2. 모델 학습을 위한 전처리 및 학습 ---
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

def create_sequences(dataset, look_back=1):
    X, y = [], []
    for i in range(len(dataset) - look_back):
        X.append(dataset[i:(i + look_back), 0])
        y.append(dataset[i + look_back, 0])
    return np.array(X), np.array(y)

X, y = create_sequences(scaled_data, look_back)
if X.shape[0] == 0:
    print("오류: Look-Back 설정이 너무 커서 학습 데이터가 생성되지 않았습니다.")
    exit()
    
X = np.reshape(X, (X.shape[0], X.shape[1], 1))

X_train = X
y_train = y

# 모델 재구축 및 학습 (Unit 200, Dropout 0.3)
model = Sequential()
model.add(LSTM(200, activation='relu', input_shape=(look_back, 1))) # <-- Unit 200으로 증가
model.add(Dropout(DROPOUT_RATE)) # <-- Dropout 0.3
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')
model.fit(X_train, y_train, epochs=EPOCHS, batch_size=BATCH_SIZE, verbose=0) 
print(f"모델 재학습 완료 (Look-Back: {look_back}, LSTM Unit: 200, Dropout: {DROPOUT_RATE}, Epochs: {EPOCHS}).")

# --- 3. 다중 스텝 미래 예측 (핵심 로직) ---

current_sequence = scaled_data[-look_back:].flatten()
future_predictions_scaled = []

# 200 스텝만큼 반복하며 예측
for _ in range(FUTURE_STEPS):
    input_for_prediction = current_sequence.reshape(1, look_back, 1)
    predicted_next_step = model.predict(input_for_prediction, verbose=0)
    
    future_predictions_scaled.append(predicted_next_step[0][0])
    
    # 시퀀스 갱신
    current_sequence = np.append(current_sequence[1:], predicted_next_step)

# 3. 예측 결과 역정규화
future_predictions_original = scaler.inverse_transform(
    np.array(future_predictions_scaled).reshape(-1, 1)
)

print(f"\n✨ {FUTURE_STEPS} 스텝 미래 예측 완료.")
print("="*50)
print(f"미래 예측 값 (첫 5 스텝): {future_predictions_original[:5].flatten()}")
print("="*50)

# --- 4. 훈련 예측 및 성능 지표 ---
train_predict_scaled = model.predict(X_train)
train_predict_original = scaler.inverse_transform(train_predict_scaled)
y_original = scaler.inverse_transform(y_train.reshape(-1, 1))

train_rmse = np.sqrt(mean_squared_error(y_original.flatten(), train_predict_original.flatten()))
train_r2 = r2_score(y_original.flatten(), train_predict_original.flatten())

# --- 5. 시각화 (미래 예측 그래프 추가) ---

full_len = len(data) + FUTURE_STEPS
full_plot = np.empty((full_len, 1))
full_plot[:, :] = np.nan 

full_plot[:len(data), :] = data

train_plot = np.empty_like(data)
train_plot[:, :] = np.nan
train_plot[look_back:len(data), :] = train_predict_original

future_plot_start = len(data)
full_plot[future_plot_start:, :] = future_predictions_original

# 그래프 그리기
plt.figure(figsize=(14, 7))

plt.plot(data, label='Original Data (Trained)', color='blue') 
plt.plot(train_plot, label='LSTM Prediction (Trained)', color='red', linestyle='--')

future_plot_start_x = len(data) - look_back
future_plot_end_x = len(data) + FUTURE_STEPS
future_sequence_for_plot = full_plot[future_plot_start_x:future_plot_end_x]

plt.plot(range(future_plot_start_x, future_plot_end_x), 
         future_sequence_for_plot, 
         label=f'Future {FUTURE_STEPS} Step Prediction', 
         color='red', linestyle=':', linewidth=2) 

plt.title(f'Volatility-Optimized LSTM Forecasting on {os.path.basename(file_path)} ({FUTURE_STEPS} Steps) (RMSE: {train_rmse:.4f}, R²: {train_r2:.4f})')
plt.xlabel('Time Step')
plt.ylabel(column_name)
plt.legend()
plt.grid(True, linestyle=':', alpha=0.6)
plt.show()
